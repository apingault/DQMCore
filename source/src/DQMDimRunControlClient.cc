  /// \file DQMDimRunControlClient.cc
/*
 *
 * DQMDimRunControlClient.cc source template automatically generated by a class generator
 * Creation date : mer. nov. 12 2014
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMDimRunControlClient.h"
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMRunControl.h"
#include "dqm4hep/DQMPlugin.h"

namespace dqm4hep
{

// run control client plugin declaration
DQM_PLUGIN_DECL( DQMDimRunControlClient , "DimRunControlClient" )

DQMCurrentRunRpcInfo::DQMCurrentRunRpcInfo(char *rpcName, DQMDimRunControlClient *pClient) :
	DimRpcInfo(rpcName, (void *) NULL, 0),
	m_pClient(pClient)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMCurrentRunRpcInfo::rpcInfoHandler()
{
	m_pClient->handleCurrentRunRpcInfo(this);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMDimRunControlClient::DQMDimRunControlClient() :
		DQMRunControlClient(),
		m_isConnected(false),
		m_pStartOfRunInfo(NULL),
		m_pEndOfRunInfo(NULL),
		m_pCurrentRunRpcInfo(NULL),
		m_pInBuffer(0)
{
	m_pOutBuffer = new xdrstream::BufferDevice( 10*1024 );
}

//-------------------------------------------------------------------------------------------------

DQMDimRunControlClient::~DQMDimRunControlClient()
{
	if( this->isConnectedToService() )
		this->disconnectFromService();

	if( m_pInBuffer )
		delete m_pInBuffer;

	delete m_pOutBuffer;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDimRunControlClient::connectToService()
{
	if(isConnectedToService())
		return STATUS_CODE_SUCCESS;

	std::string sorServiceName = "DQM4HEP/RunControl/" + this->getRunControlName() + "/START_OF_RUN";
	std::string eorServiceName = "DQM4HEP/RunControl/" + this->getRunControlName() + "/END_OF_RUN";
	std::string currentRunRpcName = "DQM4HEP/RunControl/" + this->getRunControlName() + "/CURRENT_RUN";

	m_pStartOfRunInfo = new DimUpdatedInfo(sorServiceName.c_str(), (void*) NULL, 0, this);
	m_pEndOfRunInfo = new DimUpdatedInfo(eorServiceName.c_str(), (void*) NULL, 0, this);
	m_pCurrentRunRpcInfo = new DQMCurrentRunRpcInfo( (char *) currentRunRpcName.c_str() , this );

	m_isConnected = true;

	sleep(1);
	int dummy = 0;
	m_pCurrentRunRpcInfo->setData(dummy);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDimRunControlClient::disconnectFromService()
{
	if(!isConnectedToService())
		return STATUS_CODE_SUCCESS;

	delete m_pStartOfRunInfo; m_pStartOfRunInfo = NULL;
	delete m_pEndOfRunInfo; m_pEndOfRunInfo = NULL;
	delete m_pCurrentRunRpcInfo; m_pCurrentRunRpcInfo = NULL;

	m_isConnected = false;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

bool DQMDimRunControlClient::isConnectedToService() const
{
	return m_isConnected;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDimRunControlClient::sendStartNewRun(DQMRun *pRun, const std::string &password)
{
	m_pOutBuffer->reset();

	if( xdrstream::XDR_SUCCESS != m_pOutBuffer->write( &password ))
		return STATUS_CODE_FAILURE;

	if( xdrstream::XDR_SUCCESS != pRun->stream( xdrstream::XDR_WRITE_STREAM , m_pOutBuffer ) )
		return STATUS_CODE_FAILURE;

	DimRpcInfo rpc( (char *)("DQM4HEP/RunControl/" + this->getRunControlName() + "/START_NEW_RUN").c_str(), (void *) NULL , 0 );

	// send new run signal and wait for response
	rpc.setData( (void *) m_pOutBuffer->getBuffer() , m_pOutBuffer->getPosition() );
	DQMRpcResponse *response = (DQMRpcResponse *) rpc.getData();

	if( ! response )
	{
		LOG4CXX_ERROR( dqmMainLogger, "FAILURE  ----> No response from server !");
		return STATUS_CODE_FAILURE;
	}

	if( response->m_ok )
	{
		LOG4CXX_INFO( dqmMainLogger, "OK  ----> " << response->m_pMessage );
	}
	else
	{
		LOG4CXX_ERROR( dqmMainLogger, "FAILURE  ----> " << response->m_pMessage );
		return STATUS_CODE_FAILURE;
	}

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMRunControl::startNewRun( pRun, password ));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDimRunControlClient::sendStartNewRun(int runNumber, const std::string &description, const std::string &detectorName, const std::string &password)
{
	DQMRun *pRun = new DQMRun( runNumber, description, detectorName );

	m_pOutBuffer->reset();

	if( xdrstream::XDR_SUCCESS != m_pOutBuffer->write( &password ))
		return STATUS_CODE_FAILURE;

	if( xdrstream::XDR_SUCCESS != pRun->stream( xdrstream::XDR_WRITE_STREAM , m_pOutBuffer ) )
	{
		delete pRun;
		return STATUS_CODE_FAILURE;
	}

	DimRpcInfo rpc( (char *)("DQM4HEP/RunControl/" + this->getRunControlName() + "/START_NEW_RUN").c_str(), (void *) NULL , 0 );

	// send new run signal and wait for response
	rpc.setData( (void *) m_pOutBuffer->getBuffer() , m_pOutBuffer->getPosition() );
	DQMRpcResponse *response = (DQMRpcResponse *) rpc.getData();

	if( ! response )
	{
		delete pRun;
		LOG4CXX_ERROR( dqmMainLogger, "FAILURE  ----> No response from server !");
		return STATUS_CODE_FAILURE;
	}

	if( response->m_ok )
	{
		LOG4CXX_INFO( dqmMainLogger, "OK  ----> " << response->m_pMessage );
	}
	else
	{
		LOG4CXX_ERROR( dqmMainLogger, "FAILURE  ----> " << response->m_pMessage );
		delete pRun;
		return STATUS_CODE_FAILURE;
	}

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMRunControl::startNewRun( pRun, password ));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMDimRunControlClient::sendEndCurrentRun( const std::string &password )
{
	m_pOutBuffer->reset();

	if( xdrstream::XDR_SUCCESS != m_pOutBuffer->write( &password ))
		return STATUS_CODE_FAILURE;

	if( xdrstream::XDR_SUCCESS != m_pOutBuffer->write( &password ) )
		return STATUS_CODE_FAILURE;

	DimRpcInfo rpc( (char *)("DQM4HEP/RunControl/" + this->getRunControlName() + "/END_CURRENT_RUN").c_str(), (void *) NULL , 0 );

	// send end current run signal and wait for response
	rpc.setData( (void *) m_pOutBuffer->getBuffer() , m_pOutBuffer->getPosition() );
	DQMRpcResponse *response = (DQMRpcResponse *) rpc.getData();

	if( ! response )
	{
		LOG4CXX_ERROR( dqmMainLogger, "FAILURE  ----> No response from server !");
		return STATUS_CODE_FAILURE;
	}

	if( response->m_ok )
	{
		LOG4CXX_INFO( dqmMainLogger, "OK  ----> " << response->m_pMessage );
	}
	else
	{
		LOG4CXX_ERROR( dqmMainLogger, "FAILURE  ----> " << response->m_pMessage );
		return STATUS_CODE_FAILURE;
	}

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMRunControl::endCurrentRun( password ));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void DQMDimRunControlClient::infoHandler()
{
	std::cout << "received info " << getInfo()->getName() << std::endl;
	DimInfo *pCurrentDimInfo = getInfo();

	if(m_pStartOfRunInfo == pCurrentDimInfo)
	{
		if(this->isRunning() || !this->isConnectedToService())
			return;

		dqm_char *pBuffer = static_cast<dqm_char*>(pCurrentDimInfo->getData());
		dqm_uint  bufferSize = pCurrentDimInfo->getSize();

		if(pBuffer == NULL || bufferSize == 0)
			return;

		this->configureInBuffer( pBuffer, bufferSize );

		DQMRun *pRun = new DQMRun();

		try
		{
			if( xdrstream::XDR_SUCCESS != pRun->stream( xdrstream::XDR_READ_STREAM , m_pInBuffer ) )
				throw StatusCodeException(STATUS_CODE_FAILURE);

			if(pRun->getRunNumber() < 0)
				throw StatusCodeException(STATUS_CODE_INVALID_PARAMETER);

			// run is adopted here by the run control. No need to delete
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->startNewRun(pRun));

			LOG4CXX_INFO( dqmMainLogger , "Starting new run " << this->getCurrentRun()->getRunNumber() );
		}
		catch(StatusCodeException &exception)
		{
			LOG4CXX_INFO( dqmMainLogger , "Caught exception : " << exception.what() );

			if(pRun)
				delete pRun;
		}
	}
	else if(m_pEndOfRunInfo == pCurrentDimInfo)
	{
		if(!this->isRunning() || !this->isConnectedToService())
			return;

		try
		{
			int currentRunNumber = this->getCurrentRun()->getRunNumber();
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->endCurrentRun());
			LOG4CXX_INFO( dqmMainLogger , "Ending run " << currentRunNumber );
		}
		catch(StatusCodeException &exception)
		{
			LOG4CXX_WARN( dqmMainLogger , "Couldn't stop the run (at stop) : " << exception.toString() );
			return;
		}
	}
	else
	{
		LOG4CXX_WARN( dqmMainLogger , "Unknown info handled by the run control client : " << pCurrentDimInfo->getName() );
	}
}

//-------------------------------------------------------------------------------------------------

void DQMDimRunControlClient::handleCurrentRunRpcInfo(DimRpcInfo *pRpcInfo)
{
	if( ! this->isConnectedToService() )
		return;

	DQMRun *pRun = new DQMRun();

	try
	{
		dqm_char *pBuffer = static_cast<dqm_char*>(pRpcInfo->getData());
		dqm_uint  bufferSize = pRpcInfo->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		this->configureInBuffer( pBuffer, bufferSize );

		if( xdrstream::XDR_SUCCESS != pRun->stream( xdrstream::XDR_READ_STREAM , m_pInBuffer ) )
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// run number is invalid, meaning not running
		if(pRun->getRunNumber() <= 0)
			throw StatusCodeException(STATUS_CODE_SUCCESS);

		// run is adopted here by the run control. No need to delete
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->startNewRun(pRun));

		LOG4CXX_INFO( dqmMainLogger , "Starting new run " << this->getCurrentRun()->getRunNumber() );

		// return avoids run deletion
		return;
	}
	catch(StatusCodeException &exception)
	{
	}

	if(pRun)
		delete pRun;
}

//-------------------------------------------------------------------------------------------------

void DQMDimRunControlClient::configureInBuffer( char *pBuffer , uint32_t bufferSize )
{
	if( ! m_pInBuffer )
		m_pInBuffer = new xdrstream::BufferDevice( pBuffer , bufferSize , false );
	else
		m_pInBuffer->setBuffer( pBuffer , bufferSize , false );

	m_pInBuffer->setOwner( false );
}

} 

