/*
 *
 * DQMMonitorElementClient.cc source template automatically generated by a class generator
 * Creation date : dim. mai 10 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElementClient.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMLogging.h"

// -- std headers
#include <algorithm>

namespace dqm4hep
{

DQMMeCollectorInfoRpcInfo::DQMMeCollectorInfoRpcInfo(char *rpcInfoName, DQMMonitorElementClient *pClient) :
		DimRpcInfo(rpcInfoName, (void*) DQMMonitorElementClient::m_emptyBufferStr.c_str(), DQMMonitorElementClient::m_emptyBufferStr.size()),
		m_pClient(pClient)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMeCollectorInfoRpcInfo::rpcInfoHandler()
{
	m_pClient->handleMeCollectorInfoRpcInfo(this);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMeListNameRpcInfo::DQMMeListNameRpcInfo(char *rpcInfoName, DQMMonitorElementClient *pClient) :
		DimRpcInfo(rpcInfoName, (void*) DQMMonitorElementClient::m_emptyBufferStr.c_str(), DQMMonitorElementClient::m_emptyBufferStr.size()),
		m_pClient(pClient)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMeListNameRpcInfo::rpcInfoHandler()
{
	m_pClient->handleMeListNameRpcInfo(this);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

const std::string DQMMonitorElementClient::m_emptyBufferStr = "EMPTY";

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementClient::DQMMonitorElementClient() :
		m_isConnected(false),
		m_pMeCollectorInfoRpcInfo(NULL),
		m_pMeListNameRpcInfo(NULL),
		m_pMeUpdateInfo(NULL),
		m_pCollectorStateInfo(NULL),
		m_pAvailableMeInfo(NULL),
		m_pInBuffer(0),
		m_pOutBuffer(0),
		m_updateMode(false),
		m_isCollectorRunning(false)
{
	m_pOutBuffer = new xdrstream::BufferDevice(1024*1024);
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementClient::~DQMMonitorElementClient() 
{
	if(isConnectedToService())
		disconnectFromService();

	delete m_pOutBuffer;

	if( m_pInBuffer )
		delete m_pInBuffer;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::setCollectorName(const std::string &collectorName)
{
	if(collectorName.empty())
		return STATUS_CODE_INVALID_PARAMETER;

	if(isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	m_collectorName = collectorName;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElementClient::getCollectorName() const
{
	return m_collectorName;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::connectToService()
{
	if(isConnectedToService())
		return STATUS_CODE_SUCCESS;

	std::string collectorName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/";
	std::stringstream ss;

	ss << collectorName << "COLLECTOR_INFO_RPC";
	m_pMeCollectorInfoRpcInfo = new DQMMeCollectorInfoRpcInfo((char*) ss.str().c_str(), this);

	ss.str("");
	ss << collectorName << "MONITOR_ELEMENT_NAME_LIST_RPC";
	m_pMeListNameRpcInfo = new DQMMeListNameRpcInfo((char*) ss.str().c_str(), this);

	ss.str("");
	ss << collectorName << "ME_UPDATE_SVC";
	m_pMeUpdateInfo = new DimUpdatedInfo( (char*) ss.str().c_str() , (void *) NULL , 0, this );

	ss.str("");
	ss << collectorName << "COLLECTOR_STATE_SVC";
	m_pCollectorStateInfo = new DimInfo( (char*) ss.str().c_str() , static_cast<int>(STOPPED_STATE) , this );

	ss.str("");
	ss << collectorName << "AVAILABLE_ME_SVC";
	m_pAvailableMeInfo = new DimUpdatedInfo( (char*) ss.str().c_str() , (void *) NULL , 0, this );

	m_isConnected = true;

	this->setUpdateMode(this->getUpdateMode());

	for(std::vector<DQMMonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
			endIter != iter ; ++iter)
		(*iter)->onMonitorElementClientConnect(this);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::disconnectFromService()
{
	if(!isConnectedToService())
		return STATUS_CODE_SUCCESS;

	delete m_pMeCollectorInfoRpcInfo; m_pMeCollectorInfoRpcInfo = NULL;
	delete m_pMeListNameRpcInfo; m_pMeListNameRpcInfo = NULL;
	delete m_pMeUpdateInfo; m_pMeUpdateInfo = NULL;
	delete m_pCollectorStateInfo; m_pCollectorStateInfo = NULL;
	delete m_pAvailableMeInfo; m_pAvailableMeInfo = NULL;

	m_isConnected = false;

	for(std::vector<DQMMonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
			endIter != iter ; ++iter)
		(*iter)->onMonitorElementClientDisconnect(this);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementClient::isConnectedToService() const
{
	return m_isConnected;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::queryCollectorInfo()
{
	if(!isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	char buf[] = "\0";
	m_pMeCollectorInfoRpcInfo->setData((void *) &buf[0], 1);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::queryAvailableMonitorElements(const DQMMonitorElementListNameRequest &request)
{
	if(!isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	// serialize the list
	m_pOutBuffer->reset();

	if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::write( m_pOutBuffer , request ) )
	{
		LOG4CXX_WARN( dqmMainLogger , "Couldn't write available list request" );
		return STATUS_CODE_FAILURE;
	}

	// send query
	m_pMeListNameRpcInfo->setData((void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition());

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::querySubscribedMonitorElements(const DQMMonitorElementRequest &request)
{
	if(!isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	// serialize the request
	m_pOutBuffer->reset();

	if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::write( m_pOutBuffer , request ) )
	{
		LOG4CXX_WARN( dqmMainLogger , "Couldn't write subscribed list request" );
		return STATUS_CODE_FAILURE;
	}

	// send the request
	std::string commandName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/QUERY_ME_CMD";
	DimClient::sendCommandNB( commandName.c_str() , (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() );

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::querySubscribedMonitorElements()
{
	// send empty request.
	DQMMonitorElementRequest request;
	return this->querySubscribedMonitorElements(request);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::subscribe(const DQMMonitorElementRequest &request)
{
	if(!isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	// serialize the request
	m_pOutBuffer->reset();

	if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::write( m_pOutBuffer , request ) )
	{
		LOG4CXX_WARN( dqmMainLogger , "Couldn't write me subscription request" );
		return STATUS_CODE_FAILURE;
	}

	// send the request
	std::string commandName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/SUBSCRIBE_CMD";
	DimClient::sendCommandNB( commandName.c_str() , (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() );

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::unsubscribe(const DQMMonitorElementRequest &request)
{
	if(!isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	// serialize the request
	m_pOutBuffer->reset();

	if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::write( m_pOutBuffer , request ) )
	{
		LOG4CXX_WARN( dqmMainLogger , "Couldn't write me un-subscription request" );
		return STATUS_CODE_FAILURE;
	}

	// send the request
	std::string commandName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/UNSUBSCRIBE_CMD";
	DimClient::sendCommandNB( commandName.c_str() , (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() );

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementClient::replaceSubscription(const DQMMonitorElementRequest &request)
{
	if(!isConnectedToService())
		return STATUS_CODE_NOT_ALLOWED;

	// serialize the request
	m_pOutBuffer->reset();

	if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::write( m_pOutBuffer , request ) )
		return STATUS_CODE_FAILURE;

	// send the request
	std::string commandName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/SET_SUBSCRIPTION_CMD";
	DimClient::sendCommandNB( commandName.c_str() , (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() );

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementClient::setUpdateMode(bool updateMode)
{
	if(this->isConnectedToService())
	{
		std::string commandName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/SET_UPDATE_MODE_CMD";
		DimClient::sendCommandNB( commandName.c_str() , static_cast<int>(updateMode) );
	}

	m_updateMode = updateMode;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementClient::getUpdateMode() const
{
	return m_updateMode;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementClient::addListener(DQMMonitorElementClientListener *pListener)
{
	if(NULL == pListener)
		return false;

	std::vector<DQMMonitorElementClientListener *>::iterator findIter = std::find( m_listeners.begin(), m_listeners.end(), pListener );

	// if already added, return ok
	if(m_listeners.end() != findIter)
		return true;

	m_listeners.push_back(pListener);

	return true;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementClient::removeListener(DQMMonitorElementClientListener *pListener)
{
	if(NULL == pListener)
		return;

	std::vector<DQMMonitorElementClientListener *>::iterator findIter = std::find( m_listeners.begin(), m_listeners.end(), pListener );

	if(m_listeners.end() == findIter)
		return;

	m_listeners.erase(findIter);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementClient::handleMeCollectorInfoRpcInfo(DimRpcInfo *pRpcInfo)
{
	try
	{
		if(m_listeners.empty())
			return;

		dqm_char *pBuffer = static_cast<dqm_char *>(pRpcInfo->getData());
		dqm_uint bufferSize = pRpcInfo->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			return;

		this->configureInBuffer( pBuffer , bufferSize );

		// deserialize and notify
		DQMHostInfo collectorInfo;

		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::read( m_pInBuffer , collectorInfo ) )
			return;

		for(std::vector<DQMMonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
				endIter != iter ; ++iter)
			(*iter)->monitorElementCollectorInfoReceived(this, collectorInfo);
	}
	catch(StatusCodeException &exception)
	{
	}
	catch(...)
	{
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementClient::handleMeListNameRpcInfo(DimRpcInfo *pRpcInfo)
{
	try
	{
		if(m_listeners.empty())
			return;

		dqm_char *pBuffer = static_cast<dqm_char*>(pRpcInfo->getData());
		dqm_uint bufferSize = pRpcInfo->getSize();

		if(NULL == pBuffer || 0 == bufferSize)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		this->configureInBuffer( pBuffer , bufferSize );

		// deserialize and notify
		DQMMonitorElementInfoList monitorElementInfoList;

		if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::read( m_pInBuffer , monitorElementInfoList ) )
			throw StatusCodeException(STATUS_CODE_FAILURE);

		for(std::vector<DQMMonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
				endIter != iter ; ++iter)
			(*iter)->availableMonitorElementListReceived(this, monitorElementInfoList);
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "handleMeListNameRpcInfo(): Exception caught : " << exception.toString() );
	}
	catch(...)
	{
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementClient::infoHandler()
{
	DimInfo *pInfo = getInfo();

	LOG4CXX_DEBUG( dqmMainLogger , "Received info : " << pInfo->getName() );

	if(pInfo == m_pMeUpdateInfo)
	{
		DQMPublication monitorElementPublication;

		try
		{
			if(m_listeners.empty())
				return;

			dqm_char *pBuffer = static_cast<dqm_char *>(m_pMeUpdateInfo->getData());
			dqm_uint bufferSize = m_pMeUpdateInfo->getSize();

			if(NULL == pBuffer || 0 == bufferSize)
				throw StatusCodeException(STATUS_CODE_FAILURE);

			this->configureInBuffer( pBuffer , bufferSize );

			// deserialize and call the user call back function
			if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::read( m_pInBuffer , monitorElementPublication ) )
				throw StatusCodeException(STATUS_CODE_FAILURE);

			for(std::vector<DQMMonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
					endIter != iter ; ++iter)
				(*iter)->monitorElementsReceived(this, monitorElementPublication);
		}
		catch(StatusCodeException &exception)
		{
			LOG4CXX_WARN( dqmMainLogger , "Couldn't receive monitor element publication: " << exception.toString() );
		}
		catch(...)
		{
		}
	}
	else if(pInfo == m_pCollectorStateInfo)
	{
		bool isCollectorRunning = static_cast<bool>(m_pCollectorStateInfo->getInt());

		LOG4CXX_INFO( dqmMainLogger , "Received collector state : " << isCollectorRunning );

		if(isCollectorRunning == m_isCollectorRunning)
			return;

		m_isCollectorRunning = isCollectorRunning;

		if(m_isCollectorRunning)
		{
			// send back update mode info to collector
			this->setUpdateMode(this->getUpdateMode());

			// notify server state !
			for(std::vector<DQMMonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
					endIter != iter ; ++iter)
				(*iter)->onServerStartup(this);
		}
		else
		{
			// notify server state !
			for(std::vector<DQMMonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
					endIter != iter ; ++iter)
				(*iter)->onServerShutdown(this);
		}
	}
	else if(pInfo == m_pAvailableMeInfo)
	{
		DQMMonitorElementInfoList availableMeList;

		try
		{
			if(m_listeners.empty())
				return;

			dqm_char *pBuffer = static_cast<dqm_char *>(m_pAvailableMeInfo->getData());
			dqm_uint bufferSize = m_pAvailableMeInfo->getSize();

			if(NULL == pBuffer || 0 == bufferSize)
				throw StatusCodeException(STATUS_CODE_FAILURE);

			this->configureInBuffer( pBuffer , bufferSize );

			// deserialize and call the user call back function
			if( xdrstream::XDR_SUCCESS != DQMStreamingHelper::read( m_pInBuffer , availableMeList ) )
				throw StatusCodeException(STATUS_CODE_FAILURE);

			for(std::vector<DQMMonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
					endIter != iter ; ++iter)
				(*iter)->monitorElementsAvailable(this, availableMeList);
		}
		catch(StatusCodeException &exception)
		{
			LOG4CXX_WARN( dqmMainLogger , "Couldn't receive available me: " << exception.toString() );
		}
		catch(...)
		{
		}
	}
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementClient::isCollectorRunning() const
{
	return m_isCollectorRunning;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementClient::configureInBuffer( char *pBuffer , uint32_t bufferSize )
{
	if( ! m_pInBuffer )
		m_pInBuffer = new xdrstream::BufferDevice( pBuffer , bufferSize , false );
	else
		m_pInBuffer->setBuffer( pBuffer , bufferSize , false );

	m_pInBuffer->setOwner( false );
}

} 

