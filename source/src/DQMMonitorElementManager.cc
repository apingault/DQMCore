  /// \file DQMMonitorElementManager.cc
/*
 *
 * DQMMonitorElementManager.cc source template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 17 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElementManager.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMStorage.h"
#include "dqm4hep/DQMDirectory.h"
#include "dqm4hep/DQMCoreTool.h"
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMPluginManager.h"
#include "dqm4hep/DQMQualityTest.h"

// -- root headers
#include "TH1F.h"
#include "TH1I.h"
#include "TH1S.h"
#include "TH1C.h"
#include "TH2F.h"
#include "TH2I.h"
#include "TH2S.h"
#include "TH2C.h"
#include "TH3F.h"
#include "TH3I.h"
#include "TProfile.h"
#include "TProfile2D.h"
#include "TROOT.h"
#include "TClass.h"
#include "TObject.h"

// -- std headers
#include <stdexcept>

namespace dqm4hep
{

DQMMonitorElementManager::DQMMonitorElementManager() 
{
	m_pMonitorElementStorage = new DQMStorage();
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementManager::~DQMMonitorElementManager() 
{
	delete m_pMonitorElementStorage;

	for(DQMQualityTestFactoryMap::iterator iter = m_qualityTestFactoryMap.begin(), endIter = m_qualityTestFactoryMap.end() ;
			endIter != iter ; ++iter)
		delete iter->second;

	for(DQMQualityTestMap::iterator iter = m_qualityTestMap.begin(), endIter = m_qualityTestMap.end() ;
			endIter != iter ; ++iter)
		delete iter->second;

	m_qualityTestFactoryMap.clear();
	m_qualityTestMap.clear();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementManager::cd()
{
	m_pMonitorElementStorage->cd();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::cd(const std::string &dirName)
{
	return m_pMonitorElementStorage->cd(dirName);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::mkdir(const std::string &dirName)
{
	return m_pMonitorElementStorage->mkdir(dirName);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementManager::ls(bool recursive)
{
	m_pMonitorElementStorage->ls(recursive);
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElementManager::pwd()
{
	return m_pMonitorElementStorage->pwd();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::goUp()
{
	return m_pMonitorElementStorage->goUp();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::rmdir(const std::string &dirName)
{
	return m_pMonitorElementStorage->rmdir(dirName);
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMMonitorElementManager::getCurrentDirectoryName() const
{
	return m_pMonitorElementStorage->getCurrentDirectory()->getName();
}

//-------------------------------------------------------------------------------------------------

DQMPath DQMMonitorElementManager::getCurrentDirectoryFullPathName() const
{
	return m_pMonitorElementStorage->getCurrentDirectory()->getFullPathName();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getFullPathName(const std::string &subDirName, DQMPath &fullPathName) const
{
	DQMDirectory *pDirectory = NULL;
	THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->findDir(subDirName, pDirectory));

	fullPathName = pDirectory->getFullPathName();

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementManager::dirExists(const std::string &dirName) const
{
	return m_pMonitorElementStorage->dirExists(dirName);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookObject(DQMMonitorElementPtr &monitorElement, const std::string &directory, const std::string &name, const std::string &title,
		const std::string &moduleName, const std::string &className)
{
	monitorElement = NULL;

	if(name.empty() || DQMCoreTool::containsSpecialCharacters(name) || name.find("/") != std::string::npos)
		return STATUS_CODE_INVALID_PARAMETER;

	try
	{
    	TClass *pClass = gROOT->GetClass(className.c_str());

    	if(!pClass)
    		return STATUS_CODE_FAILURE;

    	TObject *pObject = reinterpret_cast<TObject *>(pClass->New());

    	if(!pObject)
    		return STATUS_CODE_FAILURE;

		// create the monitor element
    	monitorElement = std::make_shared<DQMMonitorElement>(pObject, USER_DEFINED_ELEMENT_TYPE, name, title, moduleName);

		if(NULL == monitorElement)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		// add it to the monitor element list of the module
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->addMonitorElement(directory, monitorElement));
	}
	catch(StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqmMainLogger , "Couldn't create monitor element '" << name << "'. Status code exception caught : " << exception.toString() );
		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookMonitorElement(const TiXmlElement *const pXmlElement, const std::string &moduleName,
		const std::string &name, DQMMonitorElementPtr &monitorElement)
{
	if(NULL == pXmlElement)
		return STATUS_CODE_INVALID_PTR;

	std::string type;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "type", type));

	DQMMonitorElementType monitorElementType = stringToMonitorElementRootType(type);

	if(NO_ELEMENT_TYPE == monitorElementType || monitorElementType >= NUMBER_OF_DQM_MONITOR_ELEMENT_TYPES)
		return STATUS_CODE_INVALID_PARAMETER;

	// empty path means current directory
	std::string path;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "path", path));

	// create dir
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_ALREADY_PRESENT, !=, this->mkdir(path));

	// not mandatory
	std::string title;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "title", title));

	// not mandatory
	std::string description;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "description", description));

	// not mandatory
	std::string drawOption;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "drawOption", drawOption));

	// not mandatory
	std::string resetPolicyStr;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "resetPolicy", resetPolicyStr));

	// for scalar values
	std::string value;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "value", value));

	// switch necessary because of different xml parsing per monitor element type
	// Could be replaced at most by a polymorphic impl ... in future
	switch(monitorElementType)
	{
	case INT_ELEMENT_TYPE :
	{

		int intValue;

		if(!DQM4HEP::stringToType(value, intValue))
			return STATUS_CODE_FAILURE;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookObject(monitorElement, INT_ELEMENT_TYPE, path, name, title, moduleName, TScalarIntAllocator(), intValue));

		break;
	}
	case REAL_ELEMENT_TYPE :
	{
		float floatValue;

		if(!DQM4HEP::stringToType(value, floatValue))
			return STATUS_CODE_FAILURE;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookObject(monitorElement, REAL_ELEMENT_TYPE, path, name, title, moduleName, TScalarFloatAllocator(), floatValue));

		break;
	}
	case SHORT_ELEMENT_TYPE :
	{

		short shortValue;

		if(!DQM4HEP::stringToType(value, shortValue))
			return STATUS_CODE_FAILURE;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookObject(monitorElement, SHORT_ELEMENT_TYPE, path, name, title, moduleName, TScalarShortAllocator(), shortValue));

		break;
	}
	case STRING_ELEMENT_TYPE :
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookObject(monitorElement, STRING_ELEMENT_TYPE, path, name, title, moduleName, TScalarStringAllocator(), value));

		break;
	}
	case INT_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, INT_HISTOGRAM_1D_ELEMENT_TYPE, path, name, title, moduleName, TH1IAllocator(), nBins, min, max));

    	break;
	}
	case REAL_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, REAL_HISTOGRAM_1D_ELEMENT_TYPE, path, name, title, moduleName, TH1FAllocator(), nBins, min, max));

    	break;
	}
	case SHORT_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, SHORT_HISTOGRAM_1D_ELEMENT_TYPE, path, name, title, moduleName, TH1SAllocator(), nBins, min, max));

    	break;
	}
	case CHAR_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, CHAR_HISTOGRAM_1D_ELEMENT_TYPE, path, name, title, moduleName, TH1CAllocator(), nBins, min, max));

    	break;
	}
	case INT_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, INT_HISTOGRAM_2D_ELEMENT_TYPE, path, name, title, moduleName, TH2IAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case REAL_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, REAL_HISTOGRAM_2D_ELEMENT_TYPE, path, name, title, moduleName, TH2FAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case CHAR_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, CHAR_HISTOGRAM_2D_ELEMENT_TYPE, path, name, title, moduleName, TH2CAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case SHORT_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, SHORT_HISTOGRAM_2D_ELEMENT_TYPE, path, name, title, moduleName, TH2SAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case INT_HISTOGRAM_3D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

		int nBinsZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsZ", nBinsZ, &PositiveValidator<int>::validate ));
    	float minZ, maxZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minZ", minZ));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxZ", maxZ, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, INT_HISTOGRAM_3D_ELEMENT_TYPE, path, name, title, moduleName, TH3IAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY, nBinsZ, minZ, maxZ));

    	break;
	}
	case REAL_HISTOGRAM_3D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

		int nBinsZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsZ", nBinsZ, &PositiveValidator<int>::validate ));
    	float minZ, maxZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minZ", minZ));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxZ", maxZ, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, REAL_HISTOGRAM_3D_ELEMENT_TYPE, path, name, title, moduleName, TH3FAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY, nBinsZ, minZ, maxZ));

    	break;
	}
	case PROFILE_1D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

			// Not Mandatory
			std::string option="";
			RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "option", option));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, PROFILE_1D_ELEMENT_TYPE, path, name, title, moduleName, TProfileAllocator(), nBinsX, minX, maxX, minY, maxY, option.c_str()));

    	break;
	}
	case PROFILE_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	float minZ, maxZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minZ", minZ));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxZ", maxZ, BiggerThanValidator<float>(minZ) ));

			// Not Mandatory
			std::string option="";
			RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "option", option));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, PROFILE_2D_ELEMENT_TYPE, path, name, title, moduleName, TProfile2DAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY, minZ, maxZ, option.c_str()));

    	break;
	}
	case USER_DEFINED_ELEMENT_TYPE :
	{
		std::string rootClass;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "ROOTClass", rootClass));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookObject(monitorElement, path, name, title, moduleName, rootClass));

    	break;
	}
	default:
		return STATUS_CODE_FAILURE;
	}

	monitorElement->setDrawOption(drawOption);
	monitorElement->setDescription(description);
	monitorElement->setResetPolicy(stringToResetPolicy(resetPolicyStr));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::bookMonitorElement(const TiXmlElement *const pXmlElement, const std::string &moduleName,
		DQMMonitorElementPtr &monitorElement, const DQMParameters &parameters)
{
	if(NULL == pXmlElement)
		return STATUS_CODE_INVALID_PTR;

	std::string name;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "name", name));
	DQM4HEP::replace(name, parameters);

	std::string type;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "type", type));

	DQMMonitorElementType monitorElementType = stringToMonitorElementRootType(type);

	if(NO_ELEMENT_TYPE == monitorElementType || monitorElementType >= NUMBER_OF_DQM_MONITOR_ELEMENT_TYPES)
		return STATUS_CODE_INVALID_PARAMETER;

	// empty path means current directory
	std::string path;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "path", path));
	DQM4HEP::replace(path, parameters);

	// create dir
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_ALREADY_PRESENT, !=, this->mkdir(path));

	// not mandatory
	std::string title;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "title", title));
	DQM4HEP::replace(title, parameters);

	// not mandatory
	std::string description;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "description", description));
	DQM4HEP::replace(description, parameters);

	// not mandatory
	std::string drawOption;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "drawOption", drawOption));

	// not mandatory
	std::string resetPolicyStr;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "resetPolicy", resetPolicyStr));

	// for scalar values
	std::string value;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "value", value));

	// switch necessary because of different xml parsing per monitor element type
	// Could be replaced at most by a polymorphic impl ... in future
	switch(monitorElementType)
	{
	case INT_ELEMENT_TYPE :
	{

		int intValue;

		if(!DQM4HEP::stringToType(value, intValue))
			return STATUS_CODE_FAILURE;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookObject(monitorElement, INT_ELEMENT_TYPE, path, name, title, moduleName, TScalarIntAllocator(), intValue));

		break;
	}
	case REAL_ELEMENT_TYPE :
	{
		float floatValue;

		if(!DQM4HEP::stringToType(value, floatValue))
			return STATUS_CODE_FAILURE;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookObject(monitorElement, REAL_ELEMENT_TYPE, path, name, title, moduleName, TScalarFloatAllocator(), floatValue));

		break;
	}
	case SHORT_ELEMENT_TYPE :
	{

		short shortValue;

		if(!DQM4HEP::stringToType(value, shortValue))
			return STATUS_CODE_FAILURE;

		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookObject(monitorElement, SHORT_ELEMENT_TYPE, path, name, title, moduleName, TScalarShortAllocator(), shortValue));

		break;
	}
	case STRING_ELEMENT_TYPE :
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookObject(monitorElement, STRING_ELEMENT_TYPE, path, name, title, moduleName, TScalarStringAllocator(), value));

		break;
	}
	case INT_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, INT_HISTOGRAM_1D_ELEMENT_TYPE, path, name, title, moduleName, TH1IAllocator(), nBins, min, max));

    	break;
	}
	case REAL_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, REAL_HISTOGRAM_1D_ELEMENT_TYPE, path, name, title, moduleName, TH1FAllocator(), nBins, min, max));

    	break;
	}
	case SHORT_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, SHORT_HISTOGRAM_1D_ELEMENT_TYPE, path, name, title, moduleName, TH1SAllocator(), nBins, min, max));

    	break;
	}
	case CHAR_HISTOGRAM_1D_ELEMENT_TYPE :
	{
		int nBins;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBins", nBins, &PositiveValidator<int>::validate ));
    	float min, max;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "min", min));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "max", max, BiggerThanValidator<float>(min) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, CHAR_HISTOGRAM_1D_ELEMENT_TYPE, path, name, title, moduleName, TH1CAllocator(), nBins, min, max));

    	break;
	}
	case INT_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, INT_HISTOGRAM_2D_ELEMENT_TYPE, path, name, title, moduleName, TH2IAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case REAL_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, REAL_HISTOGRAM_2D_ELEMENT_TYPE, path, name, title, moduleName, TH2FAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case CHAR_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, CHAR_HISTOGRAM_2D_ELEMENT_TYPE, path, name, title, moduleName, TH2CAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case SHORT_HISTOGRAM_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, SHORT_HISTOGRAM_2D_ELEMENT_TYPE, path, name, title, moduleName, TH2SAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY));

    	break;
	}
	case INT_HISTOGRAM_3D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

		int nBinsZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsZ", nBinsZ, &PositiveValidator<int>::validate ));
    	float minZ, maxZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minZ", minZ));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxZ", maxZ, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, INT_HISTOGRAM_3D_ELEMENT_TYPE, path, name, title, moduleName, TH3IAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY, nBinsZ, minZ, maxZ));

    	break;
	}
	case REAL_HISTOGRAM_3D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

		int nBinsZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsZ", nBinsZ, &PositiveValidator<int>::validate ));
    	float minZ, maxZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minZ", minZ));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxZ", maxZ, BiggerThanValidator<float>(minY) ));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, REAL_HISTOGRAM_3D_ELEMENT_TYPE, path, name, title, moduleName, TH3FAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY, nBinsZ, minZ, maxZ));

    	break;
	}
	case PROFILE_1D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

			// Not Mandatory
			std::string option="";
			RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "option", option));
		
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, PROFILE_1D_ELEMENT_TYPE, path, name, title, moduleName, TProfileAllocator(), nBinsX, minX, maxX, minY, maxY, option.c_str()));

    	break;
	}
	case PROFILE_2D_ELEMENT_TYPE :
	{
		int nBinsX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsX", nBinsX, &PositiveValidator<int>::validate ));
    	float minX, maxX;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minX", minX));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxX", maxX, BiggerThanValidator<float>(minX) ));

		int nBinsY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "nBinsY", nBinsY, &PositiveValidator<int>::validate ));
    	float minY, maxY;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minY", minY));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxY", maxY, BiggerThanValidator<float>(minY) ));

    	float minZ, maxZ;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "minZ", minZ));
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "maxZ", maxZ, BiggerThanValidator<float>(minZ) ));

			// Not Mandatory
			std::string option="";
			RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::getAttribute(pXmlElement, "option", option));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookHistogram(monitorElement, PROFILE_2D_ELEMENT_TYPE, path, name, title, moduleName, TProfile2DAllocator(), nBinsX, minX, maxX, nBinsY, minY, maxY, minZ, maxZ, option.c_str()));

    	break;
	}
	case USER_DEFINED_ELEMENT_TYPE :
	{
		std::string rootClass;
    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "ROOTClass", rootClass));

    	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->bookObject(monitorElement, path, name, title, moduleName, rootClass));

    	break;
	}
	default:
		return STATUS_CODE_FAILURE;
	}

	monitorElement->setDrawOption(drawOption);
	monitorElement->setDescription(description);
	monitorElement->setResetPolicy(stringToResetPolicy(resetPolicyStr));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getAllMonitorElements(DQMMonitorElementPtrList &monitorElementList) const
{
	return m_pMonitorElementStorage->getAllMonitorElements(monitorElementList);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getMonitorElement(const std::string &monitorElementName, DQMMonitorElementPtr &monitorElement) const
{
	return m_pMonitorElementStorage->getMonitorElement(monitorElementName, monitorElement);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getMonitorElement(const std::string &dirName, const std::string &monitorElementName, DQMMonitorElementPtr &monitorElement) const
{
	return m_pMonitorElementStorage->getMonitorElement(dirName, monitorElementName, monitorElement);
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementPtr DQMMonitorElementManager::getMonitorElement(const std::string &monitorElementName) const
{
	DQMMonitorElementPtr monitorElement = NULL;
	this->getMonitorElement(monitorElementName, monitorElement);
	return monitorElement;
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementPtr DQMMonitorElementManager::getMonitorElement(const std::string &dirName, const std::string &monitorElementName) const
{
	DQMMonitorElementPtr monitorElement = NULL;
	this->getMonitorElement(dirName, monitorElementName, monitorElement);
	return monitorElement;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::deleteMonitorElement(DQMMonitorElementPtr &monitorElement)
{
	if(NULL == monitorElement)
		return STATUS_CODE_INVALID_PTR;

	const std::string fullPath = monitorElement->getPath().getPath();
	const std::string name = monitorElement->getName();

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->removeMonitorElement(fullPath, name));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::deleteMonitorElement(const std::string &dirName, const std::string &monitorElementName)
{
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pMonitorElementStorage->removeMonitorElement(dirName, monitorElementName));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::resetMonitorElements(DQMResetPolicy policy) const
{
	DQMMonitorElementPtrList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	for(DQMMonitorElementPtrList::iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter)
	{
		if(NULL == *iter)
			continue;

		if(policy == (*iter)->getResetPolicy())
			(*iter)->reset();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::resetMonitorElements() const
{
	DQMMonitorElementPtrList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	for(DQMMonitorElementPtrList::iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter)
	{
		if(NULL == *iter)
			continue;

		(*iter)->reset();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getMonitorElementListToPublish(DQMMonitorElementPtrList &monitorElementListToPublish) const
{
	DQMMonitorElementPtrList moduleElementList;
	RETURN_RESULT_IF( STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements( moduleElementList ) );

	for( DQMMonitorElementPtrList::const_iterator iter = moduleElementList.begin(), endIter = moduleElementList.end() ;
			endIter != iter ; ++iter )
	{
		if( (*iter)->isToPublish() )
			monitorElementListToPublish.push_back( *iter );
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

//StatusCode DQMMonitorElementManager::archive(DQMArchiver *pArchiver)
//{
//	if(NULL == pArchiver)
//		return STATUS_CODE_INVALID_PTR;
//
//	// TODO implements this in DQMArchiver
////	return pArchiver->archive(pModule);
//	return STATUS_CODE_FAILURE;
//}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------


StatusCode DQMMonitorElementManager::registerQualityTestFactory(const std::string &qualityTestFactoryName, const DQMQualityTestFactory *const pQualityTestFactory)
{
	if(NULL == pQualityTestFactory)
		return STATUS_CODE_INVALID_PTR;

	DQMQualityTestFactoryMap::iterator findIter = m_qualityTestFactoryMap.find(qualityTestFactoryName);

	if(m_qualityTestFactoryMap.end() != findIter)
	{
		delete pQualityTestFactory;
		return STATUS_CODE_ALREADY_PRESENT;
	}

	m_qualityTestFactoryMap[qualityTestFactoryName] = pQualityTestFactory;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::createQualityTest(TiXmlElement *const pXmlElement)
{
	std::string name;
	std::string type;

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "name", name));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::getAttribute(pXmlElement, "type", type));

	DQMQualityTestMap::iterator findIter = m_qualityTestMap.find(name);

	if(m_qualityTestMap.end() != findIter)
		return STATUS_CODE_ALREADY_PRESENT;

	DQMQualityTestFactoryMap::iterator findFactoryIter = m_qualityTestFactoryMap.find(type);

	if(m_qualityTestFactoryMap.end() == findFactoryIter)
			return STATUS_CODE_NOT_FOUND;

	DQMQualityTest *const pQualityTest = findFactoryIter->second->createQualityTest(name);
	pQualityTest->m_type = type;

	try
	{
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pQualityTest->readSettings(TiXmlHandle(pXmlElement)));
		THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pQualityTest->init());

		if(!m_qualityTestMap.insert(DQMQualityTestMap::value_type(name, pQualityTest)).second)
			throw StatusCodeException(STATUS_CODE_FAILURE);
	}
	catch(const StatusCodeException &exception)
	{
		delete pQualityTest;
		return exception.getStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::addQualityTest(DQMMonitorElementPtr &monitorElement, const std::string &qualityTestName) const
{
	if(NULL == monitorElement)
		return STATUS_CODE_INVALID_PTR;

	DQMQualityTest *pQualityTest = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getQualityTest(qualityTestName, pQualityTest));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, monitorElement->addQualityTest(pQualityTest));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTests(DQMMonitorElementPtr &monitorElement)
{
	if(NULL == monitorElement)
		return STATUS_CODE_INVALID_PTR;

	return monitorElement->runQualityTests();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTest(DQMMonitorElementPtr &monitorElement, const std::string &qualityTestName)
{
	if(NULL == monitorElement)
		return STATUS_CODE_INVALID_PTR;

	return monitorElement->runQualityTest(qualityTestName);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTests()
{
	DQMMonitorElementPtrList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	return this->runQualityTests(monitorElementList);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::runQualityTests(const DQMMonitorElementPtrList &monitorElementList)
{
	for(DQMMonitorElementPtrList::const_iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter)
	{
		DQMMonitorElementPtr monitorElement = *iter;
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->runQualityTests(monitorElement));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getQualityTest(const std::string &qualityTestName, DQMQualityTest *&pQualityTest) const
{
	pQualityTest = NULL;

	// look for an existing quality test in the map
	DQMQualityTestMap::const_iterator qTestFindIter = m_qualityTestMap.find(qualityTestName);

	if(m_qualityTestMap.end() == qTestFindIter)
		return STATUS_CODE_NOT_FOUND;

	pQualityTest = qTestFindIter->second;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMMonitorElementManager::getQualityTestResults(DQMQualityTestResultMap &results) const
{
	DQMMonitorElementPtrList monitorElementList;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->getAllMonitorElements(monitorElementList));

	for( DQMMonitorElementPtrList::const_iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter )
	{
		const DQMQualityTestResultMap &meResults( (*iter)->getQualityTestResults() );
		results.insert( meResults.begin(), meResults.end() );
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

DQMStorage *DQMMonitorElementManager::getStorage() const
{
	return m_pMonitorElementStorage;
}

} 

