  /// \file DQMStorage.cc
/*
 *
 * DQMStorage.cc source template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 19 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/DQMStorage.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMPath.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMDirectory.h"

namespace dqm4hep
{

DQMStorage::DQMStorage()
{
	m_pRootDir = new DQMDirectory("");
	m_pCurrentDir = m_pRootDir;
}

//-------------------------------------------------------------------------------------------------

DQMStorage::~DQMStorage()
{
	try{
		clear();
	}catch(StatusCodeException &exception){
		LOG4CXX_WARN( dqmMainLogger , "Failed to clear storage with exception : " << exception.toString() );
	}
	
	delete m_pRootDir;
	m_pCurrentDir = NULL;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::mkdir(const std::string &dirName)
{
	if(dirName.empty())
		return STATUS_CODE_INVALID_PARAMETER;

	DQMPath path(dirName);

	if(!path.isValid())
		return STATUS_CODE_INVALID_PARAMETER;

	DQMDirectory *pDirectory = !path.isRelative() ? m_pRootDir : m_pCurrentDir;
	StringVector directoryList = path.getSplitPath();

	for(StringVector::iterator iter = directoryList.begin(), endIter = directoryList.end() ;
			endIter != iter ; ++iter)
	{
		std::string dirName = *iter;

		if(dirName == ".")
			continue;

		if(dirName == "..")
		{
			if(pDirectory == m_pRootDir)
				return STATUS_CODE_FAILURE;

			pDirectory = pDirectory->getParentDir();
			continue;
		}

		// if sub dir doesn't exists, create it
		if(!pDirectory->containsDir(dirName))
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->mkdir(dirName));

		// navigate forward
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->findDir(dirName, pDirectory));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void DQMStorage::cd()
{
	m_pCurrentDir = m_pRootDir;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::cd(const std::string &dirName)
{
	// go back to sub dir
	if(dirName.empty())
	{
		cd();
		return STATUS_CODE_SUCCESS;
	}

	DQMPath path(dirName);

	if(!path.isValid())
		return STATUS_CODE_INVALID_PARAMETER;

	DQMDirectory *pDirectory = !path.isRelative() ? m_pRootDir : m_pCurrentDir;
	StringVector directoryList = path.getSplitPath();

	for(StringVector::iterator iter = directoryList.begin(), endIter = directoryList.end() ;
			endIter != iter ; ++iter)
	{
		std::string dirName = *iter;

		if(dirName == ".")
			continue;

		if(dirName == "..")
		{
			if(pDirectory == m_pRootDir)
				return STATUS_CODE_FAILURE;

			pDirectory = pDirectory->getParentDir();
			continue;
		}

		// navigate forward
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->findDir(dirName, pDirectory));
	}

	if(NULL == pDirectory)
		return STATUS_CODE_FAILURE;

	m_pCurrentDir = pDirectory;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void DQMStorage::ls(bool recursive) const
{
	m_pCurrentDir->ls(recursive);
}

//-------------------------------------------------------------------------------------------------

bool DQMStorage::dirExists(const std::string &dirName) const
{
	DQMDirectory *pDirectory = NULL;
	return findDir(dirName, pDirectory) == STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMStorage::pwd() const
{
	return m_pCurrentDir->getName();
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::goUp()
{
	if(m_pCurrentDir->isRootDir())
		return STATUS_CODE_NOT_ALLOWED;

	m_pCurrentDir = m_pCurrentDir->getParentDir();

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::rmdir(const std::string &dirName)
{
	if(dirName.empty())
		return STATUS_CODE_NOT_ALLOWED;

	DQMDirectory *pDirectory = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

	if(pDirectory == m_pRootDir)
		return STATUS_CODE_NOT_ALLOWED;

	std::string fullPathDirName = pDirectory->getFullPathName().getPath();
	std::string currentFullPathDirName = m_pCurrentDir->getFullPathName().getPath();
	size_t pos = currentFullPathDirName.find(fullPathDirName);

	// this mean that the directory that we try
	// to remove is a parent of the current one.
	if(pos == 0 || pos != std::string::npos)
		return STATUS_CODE_FAILURE;

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->getParentDir()->removeDir(pDirectory->getName()));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::findDir(const std::string &dirName, DQMDirectory *&pDirectory) const
{
	pDirectory = NULL;

	// go back to sub dir
	if(dirName.empty() || dirName == "." || dirName == "./")
	{
		pDirectory = m_pCurrentDir;
		return STATUS_CODE_SUCCESS;
	}

	DQMPath path(dirName);

	if(!path.isValid())
		return STATUS_CODE_INVALID_PARAMETER;

	pDirectory = !path.isRelative() ? m_pRootDir : m_pCurrentDir;
	StringVector directoryList = path.getSplitPath();

	for(StringVector::iterator iter = directoryList.begin(), endIter = directoryList.end() ;
			endIter != iter ; ++iter)
	{
		std::string dirName = *iter;

		if(dirName == ".")
			continue;

		if(dirName == "..")
		{
			if(pDirectory == m_pRootDir)
				return STATUS_CODE_FAILURE;

			pDirectory = pDirectory->getParentDir();
			continue;
		}

		// navigate forward
		StatusCode statusCode = pDirectory->findDir(dirName, pDirectory);

		if(statusCode != STATUS_CODE_SUCCESS)
			return statusCode;
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

DQMDirectory *DQMStorage::getRootDirectory() const
{
	return m_pRootDir;
}

//-------------------------------------------------------------------------------------------------

DQMDirectory *DQMStorage::getCurrentDirectory() const
{
	return m_pCurrentDir;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::addMonitorElement(const DQMMonitorElementPtr &monitorElement)
{
	DQMPath path = m_pCurrentDir->getFullPathName();
	monitorElement->setPath(path);

	return m_pCurrentDir->addMonitorElement(monitorElement);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::addMonitorElement(const std::string &dirName, const DQMMonitorElementPtr &monitorElement)
{
	DQMDirectory *pDirectory = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, mkdir(dirName));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

	DQMPath path = pDirectory->getFullPathName();
	monitorElement->setPath(path);

	return pDirectory->addMonitorElement(monitorElement);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::removeMonitorElement(const std::string &monitorElementName)
{
	DQMMonitorElementPtr monitorElement;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pCurrentDir->findMonitorElement(monitorElementName, monitorElement));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pCurrentDir->removeMonitorElement(monitorElement));

	monitorElement->setPath(DQMPath(""));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::removeMonitorElement(const std::string &dirName, const std::string &monitorElementName)
{
	DQMDirectory *pDirectory = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

	DQMMonitorElementPtr monitorElement;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->findMonitorElement(monitorElementName, monitorElement));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->removeMonitorElement(monitorElement));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::getMonitorElement(const std::string &monitorElementName, DQMMonitorElementPtr &monitorElement) const
{
	monitorElement = NULL;
	return m_pCurrentDir->findMonitorElement(monitorElementName, monitorElement);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::getMonitorElement(const std::string &dirName, const std::string &monitorElementName, DQMMonitorElementPtr &monitorElement) const
{
	DQMDirectory *pDirectory = NULL;
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

	return pDirectory->findMonitorElement(monitorElementName, monitorElement);
}

//-------------------------------------------------------------------------------------------------

bool DQMStorage::monitorElementExists(const DQMMonitorElementPtr &monitorElement) const
{
	return m_pCurrentDir->containsMonitorElement(monitorElement);
}

//-------------------------------------------------------------------------------------------------

bool DQMStorage::monitorElementExists(const std::string &dirName, const DQMMonitorElementPtr &monitorElement) const
{
	DQMDirectory *pDirectory = NULL;

	if( ! this->dirExists(dirName) )
		return false;

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

	return pDirectory->containsMonitorElement(monitorElement);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::getAllMonitorElements(DQMMonitorElementPtrList &monitorElementList)
{
	return DQMStorage::recursiveContentList(m_pRootDir, monitorElementList);
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::recursiveContentList(DQMDirectory *pDirectory, DQMMonitorElementPtrList &monitorElementList)
{
	if(NULL == pDirectory)
		return STATUS_CODE_INVALID_PTR;

	// add directory contents
	const DQMMonitorElementPtrList &directoryMonitorElementList(pDirectory->getMonitorElementList());
	monitorElementList.insert(monitorElementList.end(), directoryMonitorElementList.begin(), directoryMonitorElementList.end());

	// get the sub dir list ...
	const std::vector<DQMDirectory*> &subDirList(pDirectory->getSubDirList());

	if( subDirList.empty() )
		return STATUS_CODE_SUCCESS;

	// ... and loop over to add the contents
	for(std::vector<DQMDirectory*>::const_iterator iter = subDirList.begin(), endIter = subDirList.end() ;
			endIter != iter ; ++iter)
	{
		RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMStorage::recursiveContentList(*iter, monitorElementList));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMStorage::clear()
{
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRootDir->clear());
	m_pCurrentDir = m_pRootDir;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

} 

