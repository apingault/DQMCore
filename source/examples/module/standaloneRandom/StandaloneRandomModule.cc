  /// \file StandaloneRandomModule.cc
/*
 *
 * StandaloneRandomModule.cc source template automatically generated by a class generator
 * Creation date : sam. nov. 1 2014
 *
 * This file is part of LCDQM libraries.
 * 
 * LCDQM is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * LCDQM is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with LCDQM.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "standaloneRandom/StandaloneRandomModule.h"

// -- std headers
#include <ctime>
#include <cstdlib>
#include <limits>

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMPlugin.h"

// -- root headers
#include "TRandom.h"

namespace dqm4hep
{

// module plugin declaration
DQM_PLUGIN_DECL( StandaloneRandomModule , "StandaloneRandomModule" )

//-------------------------------------------------------------------------------------------------

StandaloneRandomModule::StandaloneRandomModule()
 : DQMStandaloneModule(),m_min(0),m_max(0)
{
	setVersion(1, 0, 0);
}

//-------------------------------------------------------------------------------------------------

StandaloneRandomModule::~StandaloneRandomModule()
{
}

//-------------------------------------------------------------------------------------------------

StatusCode StandaloneRandomModule::readSettings(const TiXmlHandle xmlHandle)
{
	LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- readSettings()" );

	m_min = -400;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
			"Min", m_min));

	m_max = 400;
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
			"Max", m_max));

	// max must be greater than min ...
	if(m_min >= m_max)
		return STATUS_CODE_INVALID_PARAMETER;

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode StandaloneRandomModule::startOfCycle()
{
	/* nop */
	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode StandaloneRandomModule::endOfCycle()
{
	/* nop */
	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode StandaloneRandomModule::initModule()
{
	LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- init()" );
	srand(time(NULL));

	DQMModuleApi::cd(this);

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::bookRealHistogram1D(this,
			m_pTestElement, "TEST_ELEMENT", "A real histogram in 1D with random values", m_max-m_min+1, m_min, m_max));
	m_pTestElement->setDescription(
			"Histogram filled with random values between " + DQM4HEP::typeToString(m_min) + " to " + DQM4HEP::typeToString(m_max));

	// print directory structure of monitor element storage in console
	DQMModuleApi::ls(this, true);

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode StandaloneRandomModule::endModule()
{
	LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- end()" );
	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

StatusCode StandaloneRandomModule::process()
{
	TRandom r(time(0));

	unsigned int randReentrant = time(0);
	int randomValue = round( (rand_r(&randReentrant)/(float)RAND_MAX )*(m_max-m_min) + m_min );

	m_pTestElement->get<TH1F>()->Fill(randomValue);

	return STATUS_CODE_SUCCESS;
}

} 

