  /// \file DQMStorage.h
/*
 *
 * DQMStorage.h header template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 19 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQMSTORAGE_H
#define DQMSTORAGE_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"

namespace dqm4hep
{

class DQMMonitorElement;
class DQMDirectory;

/** DQMStorage class.
 *
 *  A simple storage class for monitor elements
 *  with a directory structure (see DQMDirectory).
 *
 *  All dirName strings passed in argument of this interface
 *  refers to an absolute path if it starts by the '/' character.
 *  In this case it is considered to start from the root dir and else
 *  from the current directory.
 */ 
class DQMStorage
{
public:
	/** Constructor.
	 */
	DQMStorage();

	/** Destructor
	 */
	~DQMStorage();

	/** Create a new directory
	 */
	StatusCode mkdir(const std::string &dirName);

	/** Go back to root directory
	 */
	void cd();

	/** Go to directory.
	 *
	 *  If dirName starts with '/' then the path is
	 *  absolute and refers to the root directory.
	 *  Any directory matching ".." referes to the
	 *  parent dir (unix style)
	 */
	StatusCode cd(const std::string &dirName);

	/** List the current directory contents
	 */
	void ls(bool recursive = false) const;

	/** Whether the directory exists
	 */
	bool dirExists(const std::string &dirName) const;

	/** Get the current directory name
	 */
	const std::string &pwd() const;

	/** Navigate backward in the directory structure.
	 *  Equivalent to cd("..")
	 */
	StatusCode goUp();

	/** Remove the given directory.
	 *
	 *  It can't be the root directory
	 *  or a parent directory of the current directory. The contents
	 *  will be deleted if the flag 'owner' in the constructor has
	 *  been passed. Users can check the flag using the method isOwner()
	 *  and take appropriate action to avoid memory leak
	 */
	StatusCode rmdir(const std::string &fullDirName);

	/** Add a monitor element to the current directory
	 */
	StatusCode addMonitorElement(const DQMMonitorElementPtr &monitorElement);

	/** Add a monitor element to the given directory
	 */
	StatusCode addMonitorElement(const std::string &dirName, const DQMMonitorElementPtr &monitorElement);

	/** Remove a monitor element from the current directory
	 */
	StatusCode removeMonitorElement(const std::string &monitorElementName);

	/** Remove a monitor element from the given directory
	 */
	StatusCode removeMonitorElement(const std::string &dirName, const std::string &monitorElementName);

	/** Get the monitor element in the current directory
	 */
	StatusCode getMonitorElement(const std::string &monitorElementName, DQMMonitorElementPtr &monitorElement) const;

	/** Get the monitor element in the given directory
	 */
	StatusCode getMonitorElement(const std::string &dirName, const std::string &monitorElementName, DQMMonitorElementPtr &monitorElement) const;

	/** Get all monitor elements in all the directories starting from the root directory
 	 */
	StatusCode getAllMonitorElements(DQMMonitorElementPtrList &monitorElementList);

	/** Whether the monitor element exists in the current dir
	 */
	bool monitorElementExists(const DQMMonitorElementPtr &monitorElement) const;

	/** Whether the monitor element exists in the current dir
	 */
	bool monitorElementExists(const std::string &dirName, const DQMMonitorElementPtr &monitorElement) const;

	/** Clear the storage.
	 */
	StatusCode clear();

	/** Get the root directory
	 */
	DQMDirectory *getRootDirectory() const;

	/** Get the current directory
	 */
	DQMDirectory *getCurrentDirectory() const;

	/** Find a sub directory
	 */
	StatusCode findDir(const std::string &dirName, DQMDirectory *&pDirectory) const;

	/** Get recursively all the monitor elements in the sub dirs
	 */
	static StatusCode recursiveContentList(DQMDirectory *pDirectory, DQMMonitorElementPtrList &monitorElementList);

private:

	DQMDirectory                *m_pCurrentDir;
	DQMDirectory                *m_pRootDir;
//    bool                        m_isOwner;
};

} 

#endif  //  DQMSTORAGE_H
