  /// \file DQMGenericEvent.h
/*
 *
 * DQMGenericEvent.h header template automatically generated by a class generator
 * Creation date : lun. mars 7 2016
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQMGENERICEVENT_H
#define DQMGENERICEVENT_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMEventStreamer.h"

// -- xdrstream headers
#include "xdrstream/xdrstream.h"

namespace dqm4hep
{

class DQMGenericEventStreamer;

/** DQMGenericEvent class
 *
 *  Basic event implementation with a list of vectors stored in maps.
 *  See DQMGenericEvent::setValues() and DQMGenericEvent::getValues() to
 *  respectively set and get values into these map.
 *
 *  To get this kind of event within an analysis module, proceed like this :
 *
 *  \code
 *
 *  StatusCode MyModule::processEvent(DQMEvent *pEvent) {
 *
 *  	DQMGenericEvent *pGenericEvent = pEvent->getEvent<DQMGenericEvent>();
 *
 *      // Access contents via getValues()
 *  	FloatVector temperatures;
 *  	pGenericEvent->getValues("Temperature", temperatures);
 *  	// ...
 *  }
 *
 *  \endcode
 */
class DQMGenericEvent
{
public:
	/** Constructor
	 */
	DQMGenericEvent();

	/** Constructor
	 */
	DQMGenericEvent(int eventNumber);

	/** Constructor
	 */
	DQMGenericEvent(int runNumber, int eventNumber);

	/** Destructor
	 */
	~DQMGenericEvent();

	/** Set the event number
	 */
	void setEventNumber(int eventNumber);

	/** Get the event number
	 */
	int getEventNumber() const;

	/** Set the run number
	 */
	void setRunNumber(int runNumber);

	/** Get the run number
	 */
	int getRunNumber() const;

	/** Set the event time stamp
	 */
	void setTimeStamp(int64_t timeStamp);

	/** Get the event time stamp
	 */
	int64_t getTimeStamp() const;

	/** Set the detector name that has generated this event
	 */
	void setDetectorName(const std::string &detectorName);

	/** Get the detector name that has generated this event
	 */
	const std::string &getDetectorName() const;

	/** Set the event description
	 */
	void setDescription(const std::string &description);

	/** Get the event description
	 */
	const std::string &getDescription() const;

	/** Set a vector of values identified by key.
	 *
	 *  Attention : Template interface restricted to the following types :
	 *    - vector<int>
	 *    - vector<float>
	 *    - vector<double>
	 *    - vector<string>
	 *  In case where an another parameter type is passed, the code will compile
	 *  but will do nothing and return failure.
	 */
	template <typename T>
	StatusCode setValues(const std::string &key, const T &vals);

	/** Get a vector of values identified by key.
	 *
	 *  Attention : Template interface restricted to the following types :
	 *    - vector<int>
	 *    - vector<float>
	 *    - vector<double>
	 *    - vector<string>
	 *  In case where an another parameter type is passed, the code will compile
	 *  but will do nothing and return failure.
	 */
	template <typename T>
	StatusCode getValues(const std::string &key, T &vals) const;

private:
	/** Workhorse of DQMGenericEvent::setValues(key, vals)
	 */
	template <typename T>
	StatusCode setValuesPrivate(const std::string &key, std::map<std::string, T > &valuesMap, const T &vals);

	/** Workhorse of DQMGenericEvent::getValues(key, vals)
	 */
	template <typename T>
	StatusCode getValuesPrivate(const std::string &key, std::map<std::string, T > &valuesMap, T &vals) const;

private:
	typedef  std::map<std::string, IntVector> IntVectorMap;
	typedef  std::map<std::string, FloatVector> FloatVectorMap;
	typedef  std::map<std::string, DoubleVector> DoubleVectorMap;
	typedef  std::map<std::string, StringVector> StringVectorMap;

	int                                     m_eventNumber;
	int                                     m_runNumber;
	int64_t                                 m_timeStamp;
	std::string                             m_detectorName;
	std::string                             m_description;

	mutable IntVectorMap                    m_intValues;
	mutable FloatVectorMap                  m_floatValues;
	mutable DoubleVectorMap                 m_doubleValues;
	mutable StringVectorMap                 m_stringValues;

	friend class DQMGenericEventStreamer;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** DQMGenericEventBase class.
 *
 *  DQM e√®vent implementation, wrapping a DQMGenericEvent object
 */ 
class DQMGenericEventBase : public DQMEventBase<DQMGenericEvent>
{
public:
	/** Constructor
	 */
	DQMGenericEventBase();

	/** Destructor
	 */
	~DQMGenericEventBase();

	/** Returns the stored event
	 */
	DQMGenericEvent *getEvent() const;

	/** Set the handled event
	 */
	void setEvent(DQMGenericEvent *pGenericEvent);

	/** Clear the handler by deleting the handled event
	 */
	void clear();

private:
	DQMGenericEvent                 *m_pGenericEvent;    ///< The wrapped generic event
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/**
 * @brief DQMGenericEventStreamer class
 */
class DQMGenericEventStreamer : public DQMEventStreamer
{
public:
	/** Constructor
	 */
	DQMGenericEventStreamer();

	/** Destructor
	 */
	~DQMGenericEventStreamer();

	/** Factory method to create the corresponding DQM event to this streamer.
	 *  The dqm event is expected to contains an allocated wrapped event
	 */
	DQMEvent *createEvent() const;

	/** Serialize the event and store it into a data stream.
	 */
	StatusCode write(const DQMEvent *const pEvent, xdrstream::IODevice *pDevice);

	/** De-serialize the lcio event.
	 */
	StatusCode read(DQMEvent *&pEvent, xdrstream::IODevice *pDevice);

	/** Serialize the a part of the event and store it into a data stream.
	 */
	StatusCode write(const DQMEvent *const pObject, const std::string &subEventIdentifier, xdrstream::IODevice *pDevice);
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

template <typename T>
StatusCode DQMGenericEvent::setValues(const std::string &/*key*/, const T &/*vals*/)
{
	return STATUS_CODE_FAILURE;
}

//-------------------------------------------------------------------------------------------------

template <typename T>
StatusCode DQMGenericEvent::getValues(const std::string &/*key*/, T &/*vals*/) const
{
	return STATUS_CODE_FAILURE;
}

//-------------------------------------------------------------------------------------------------

template <typename T>
inline StatusCode DQMGenericEvent::setValuesPrivate(const std::string &key, std::map<std::string, T > &valuesMap, const T &vals)
{
	valuesMap[ key ] = vals;
	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

template <typename T>
inline StatusCode DQMGenericEvent::getValuesPrivate(const std::string &key, std::map<std::string, T > &valuesMap, T &vals) const
{
	vals = valuesMap[ key ];
	return STATUS_CODE_SUCCESS;
}

} 

#endif  //  DQMGENERICEVENT_H
